/*
** 代码分析
【1】 class_create 与 device_create 有什么区别与联系？
在Linux驱动开发中，class_create和device_create是自动创建设备节点的核心函数，它们的作用及关联如下：
1. class_create()
作用：在/sys/class/目录下动态创建设备类（逻辑分类），为后续设备节点的创建提供分类容器。
参数：
	owner：模块所有者（通常为THIS_MODULE）
	name：类名（如"my_chrdev"），对应/sys/class/下的子目录
	返回值：指向struct class的指针，失败返回错误指针（需用IS_ERR检查）
	底层实现：调用__class_create()初始化类结构体，并注册到sysfs中
	资源释放：卸载模块时需调用class_destroy()删除类

2. device_create()
	作用：在已创建的类下生成设备节点，并触发udev机制在/dev/目录下自动创建设备文件。
	参数：
	class：class_create()返回的类指针
	parent：父设备（通常为NULL）
	devt：设备号（通过MKDEV(major, minor)生成）
	fmt：设备节点名称（如"mydevice"，对应/dev/mydevice）
	返回值：指向struct device的指针，失败返回错误指针
	依赖关系：必须已调用class_create()创建类，否则无法生成设备节点
	资源释放：卸载模块时需先调用device_destroy()再销毁类
	

class_create	逻辑分类		/sys/class/	无
device_create	物理设备节点	/dev/		需先创建类

注意：两者需配合使用，单独调用device_create无法生成设备节点。现代驱动开发中，这种机制替代了手动mknod，通过udev/mdev实现动态设备管理。


*/

## 部署编译产出的 .ko 文件到开发板

为了方便讲编译后产出的 .ko 文件放入 STM32MP157d 开发板的 linux 文件系统内的合适路径下，进行后续的 insmod 。需要有一个拷贝操作。这里既可以编写一个 shell 脚本文件独立执行，更推荐在 Makefile 文件内添加一个 名为 deploy 的伪目标执行。

shell 脚本经过验证OK，代码如下：

```shell
#!/bin/bash

#验证通过OK。2025年4月6日11:14:10,主要就是实现代码拷贝。
# sudo cp -f /home/ericedward/linux_space/linux_driver/chrdev/01_chrdev/**.ko /home/ericedward/linux_space/tools/nfs/rootfs/home/maple/linux_driver/chrdev/01_chrdev/

# 配置源目录和目标目录
SOURCE_DIR="/home/ericedward/linux_space/linux_driver/chrdev/01_chrdev"
TARGET_DIR="/home/ericedward/linux_space/tools/nfs/rootfs/home/maple/linux_driver/chrdev/01_chrdev"
FILE_EXT=".ko"  # 明确指定文件类型

# 日志记录
LOG_FILE="/var/log/ko_file_copy_$(date +%Y%m%d).log"
exec > >(tee -a "$LOG_FILE") 2>&1  # 同时输出到屏幕和日志文件

echo "===== 开始执行 $(date) ====="

# 检查目录有效性
check_directory() {
    if [ ! -d "$1" ]; then
        echo "错误：目录 $1 不存在"
        return 1
    fi
    return 0
}

# 主执行函数
copy_ko_files() {
    echo "正在复制 $FILE_EXT 文件..."
    
    # 使用find命令确保精确匹配
    find "$SOURCE_DIR" -maxdepth 1 -type f -name "*$FILE_EXT" -print0 | while IFS= read -r -d $'\0' file; do
        echo "正在处理: $(basename "$file")"
        sudo cp -fv "$file" "$TARGET_DIR/"
    done
    
    echo "复制操作完成"
}

# 主程序
main() {
    check_directory "$SOURCE_DIR" || exit 1
    check_directory "$TARGET_DIR" || {
        echo "尝试创建目标目录..."
        sudo mkdir -p "$TARGET_DIR" || {
            echo "无法创建目标目录"
            exit 1
        }
    }
    
    copy_ko_files
}

main

echo "===== 执行结束 $(date) ====="

```

Makefile的代码如下：

```makefile
#验证通过OK。2025年4月6日11:14:10。
# 临时禁用模块签名验证功能
CONFIG_MODULE_SIG = n

# KDIR 是开发板所使用的源代码的 Linux 内核源码的根目录
KDIR := /home/ericedward/linux_space/linux_kernel/my_linux_kernel/linux-stm32mp-5.4.31-r0/linux-5.4.31/
CURRENT_PATH := $(shell pwd)
TARGET_PATH  := /home/ericedward/linux_space/tools/nfs/rootfs/home/maple/linux_driver/chrdev/01_chrdev/

# 指定生成模块目标
obj-m += demo_chrdev.o

all:
# modules 不是 Makefile 关键字，但在 Linux 内核驱动开发中常用作目标名称，用于编译内核模块（生成 .ko 文件）
# M 表示模块的源码目录。“make modules”命令根据M指定的路径，编码模块源码。
	$(MAKE) -C $(KDIR) M=$(CURRENT_PATH) modules

clean:
# clean 是 Makefile 中常见的伪目标（phony target），用于清理编译生成的文件。
# clean不是关键字，但广泛用于伪目标声明，需通过 .PHONY: clean 声明为伪目标，避免与同名文件冲突。
	$(MAKE) -C $(KDIR) M=$(CURRENT_PATH) clean

deploy:
# 将编译产出的 .ko 可执行文件，复制到STM32MP157d开发板对应的linux文件系统内的合适的路径下。
# scp 是安全拷贝命令，security cp，跨主机拷贝命令。不跨主机直接使用 cp 。
# sudo scp $(CURRENT_PATH)/**.ko $(TARGET_PATH)
	sudo cp $(CURRENT_PATH)/**.ko $(TARGET_PATH)
```

![image-20250406111604390](./assets/image-20250406111604390.png)

所以，以后可以不用执行 cp-update.sh 脚本文件，直接执行 make deploy 即可。

### **补充：linux shell 命令 cp 和 scp 的区别？**

`cp` 和 `scp` 是 Linux 中用于文件复制的两个命令，但它们的用途和功能有显著区别：

### 1. **cp（本地复制）**
- **作用范围**：仅用于**同一台主机**上的文件或目录复制。
- **语法**：
  ```bash
  cp [选项] 源文件 目标文件
  cp [选项] 源文件... 目标目录
  ```
- **常用选项**：
  - `-r`：递归复制目录。
  - `-i`：覆盖前提示确认。
  - `-a`：保留文件属性（权限、时间戳等）并递归复制。
- **示例**：
  ```bash
  cp file.txt /backup/          # 复制文件到目录
  cp -r dir1/ dir2/             # 递归复制目录
  ```

### 2. **scp（安全远程复制）**
- **作用范围**：用于**不同主机之间**通过 SSH 加密传输文件。
- **依赖条件**：需要目标主机的 SSH 服务正常运行。
- **语法**：
  ```bash
  scp [选项] 源文件 目标主机:目标路径
  ```
- **常用选项**：
  - `-r`：递归复制目录。
  - `-P 端口号`：指定 SSH 端口（默认 22）。
  - `-i 私钥文件`：指定认证密钥。
- **示例**：
  ```bash
  scp file.txt user@remote:/path/   # 本地→远程
  scp user@remote:/file.txt ./      # 远程→本地
  ```

### 3. **核心区别**
| **特性**     | **cp**             | **scp**                    |
| ------------ | ------------------ | -------------------------- |
| **传输范围** | 仅限本地           | 跨主机（本地↔远程）        |
| **安全性**   | 无加密             | 基于 SSH 加密传输          |
| **依赖服务** | 无需额外服务       | 需远程主机开启 SSH         |
| **典型用途** | 本地备份、文件整理 | 服务器间文件迁移、远程备份 |

### 4. **注意事项**
- **权限问题**：`scp` 需要远程主机的登录权限（用户名/密码或密钥）。
- **性能差异**：`scp` 因加密和网络开销，速度可能慢于本地 `cp`。
- **替代工具**：大文件传输或增量同步可考虑 `rsync`（更高效）。

根据需求选择：本地操作用 `cp`，跨主机传输用 `scp`。







## register_chrdev 是旧的方式注册吗？

是的，`register_chrdev` 是 Linux 内核早期版本（如 2.4 和早期 2.6 内核）中使用的字符设备注册方式，属于**旧版 API**。以下是关键分析：

### 1. **旧版 API 的特点**
- **功能范围**：  
  `register_chrdev` 会一次性注册主设备号及其对应的**所有次设备号（0~255）**，导致设备号浪费。
- **静态依赖**：  
  需开发者手动确认主设备号是否可用，易引发冲突。
- **简化接口**：  
  仅需主设备号、设备名和 `file_operations` 结构体，但灵活性差。

### 2. **新版替代方案**
Linux 推荐使用以下组合替代 `register_chrdev`：  
- **动态分配设备号**：`alloc_chrdev_region`  
- **静态指定设备号**：`register_chrdev_region`  
- **配合 `cdev` 结构体**：通过 `cdev_init` 和 `cdev_add` 注册设备。

### 3. **新旧对比**
| **特性**         | `register_chrdev` (旧)    | 新版 API (`cdev` + `*_chrdev_region`) |
| ---------------- | ------------------------- | ------------------------------------- |
| **设备号管理**   | 占用全部次设备号（0~255） | 按需分配指定数量的次设备号            |
| **灵活性**       | 低，需手动管理主设备号    | 高，支持动态分配和精确控制            |
| **内核版本适配** | 仅兼容旧内核              | 适用于现代内核（2.6+）                |

### 4. **代码迁移建议**
若需升级旧驱动，应将 `register_chrdev` 替换为：  
```c
// 动态分配示例
alloc_chrdev_region(&dev, 0, 1, "my_device");
cdev_init(&my_cdev, &fops);
cdev_add(&my_cdev, dev, 1);
```

### 总结
`register_chrdev` 已逐渐被淘汰，现代驱动开发应使用 `cdev` 结合 `alloc_chrdev_region`/`register_chrdev_region`，以提高资源利用率和兼容性。



## class_create 函数

```c
#define class_create(owner, name)		\
({						\
	static struct lock_class_key __key;	\
	__class_create(owner, name, &__key);	\
})

/**
 * class_create - create a struct class structure
 * @owner: pointer to the module that is to "own" this struct class
 * @name: pointer to a string for the name of this class.
 * @key: the lock_class_key for this class; used by mutex lock debugging
 *
 * This is used to create a struct class pointer that can then be used
 * in calls to device_create().
 *
 * Returns &struct class pointer on success, or ERR_PTR() on error.
 *
 * Note, the pointer created here is to be destroyed when finished by
 * making a call to class_destroy().
 */
struct class *__class_create(struct module *owner, const char *name,
			     struct lock_class_key *key)
{
	struct class *cls;
	int retval;

	cls = kzalloc(sizeof(*cls), GFP_KERNEL); /* 申请存储空间 */
	if (!cls) {
		retval = -ENOMEM;
		goto error;
	}

	cls->name = name;
	cls->owner = owner;
	cls->class_release = class_create_release; /* 构造结构体变量 */
   
	retval = __class_register(cls, key);  /* 注册操作 */

	return cls;
}

int __class_register(struct class *cls, struct lock_class_key *key)  /* 实际的注册函数 */
{
	struct subsys_private *cp;
	int error;

	pr_debug("device class '%s': registering\n", cls->name);

	cp = kzalloc(sizeof(*cp), GFP_KERNEL);
	if (!cp)
		return -ENOMEM;
	klist_init(&cp->klist_devices, klist_class_dev_get, klist_class_dev_put);
	INIT_LIST_HEAD(&cp->interfaces);
	kset_init(&cp->glue_dirs);
	__mutex_init(&cp->mutex, "subsys mutex", key);
	error = kobject_set_name(&cp->subsys.kobj, "%s", cls->name);
	if (error) {
		kfree(cp);
		return error;
	}

	/* set the default /sys/dev directory for devices of this class */
	if (!cls->dev_kobj)
		cls->dev_kobj = sysfs_dev_char_kobj;

#if defined(CONFIG_BLOCK)
	/* let the block class directory show up in the root of sysfs */
	if (!sysfs_deprecated || cls != &block_class)
		cp->subsys.kobj.kset = class_kset;
#else
	cp->subsys.kobj.kset = class_kset;
#endif
	cp->subsys.kobj.ktype = &class_ktype;
	cp->class = cls;
	cls->p = cp;

	error = kset_register(&cp->subsys);
	if (error) {
		kfree(cp);
		return error;
	}
	error = class_add_groups(class_get(cls), cls->class_groups);
	class_put(cls);
	if (error) {
		kobject_del(&cp->subsys.kobj);
		kfree_const(cp->subsys.kobj.name);
		kfree(cp);
	}
	return error;
}
```

**返回值**

内核驱动与用户态程序不同，局部变量的作用域和生命周期需严格匹配内核对象的持久性要求。

1. 内核对象的生命周期
class_create 返回的 struct class* 指针是内核动态分配的对象，其生命周期需与模块一致（即模块加载时创建，卸载时销毁）。若存储为局部变量，函数退出后指针将丢失，导致无法在模块卸载时通过 class_destroy 正确释放资源，引发内存泄漏或内核错误。
2. 错误处理要求
返回值需通过 IS_ERR() 检查是否创建失败。若为局部变量，错误处理逻辑（如返回错误码）将无法传递指针到模块的其他函数（如 device_create 或退出函数）。



## device_create 函数

```c
/** xref: /linux-5.4.290/drivers/base/core.c
 * device_create - creates a device and registers it with sysfs
 * @class: pointer to the struct class that this device should be registered to
 * @parent: pointer to the parent struct device of this new device, if any
 * @devt: the dev_t for the char device to be added
 * @drvdata: the data to be added to the device for callbacks
 * @fmt: string for the device's name
 *
 * This function can be used by char device classes.  A struct device
 * will be created in sysfs, registered to the specified class.
 *
 * A "dev" file will be created, showing the dev_t for the device, if
 * the dev_t is not 0,0.
 * If a pointer to a parent struct device is passed in, the newly created
 * struct device will be a child of that device in sysfs.
 * The pointer to the struct device will be returned from the call.
 * Any further sysfs files that might be required can be created using this
 * pointer.
 *
 * Returns &struct device pointer on success, or ERR_PTR() on error.
 *
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
	dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);
	va_end(vargs);
	return dev;
}
EXPORT_SYMBOL_GPL(device_create);
```

`device_create()` 是 Linux 内核中用于动态创建设备节点的关键函数，其核心功能是通过 `sysfs` 和 `udev` 机制自动在 `/dev` 目录下生成设备文件。以下是详细分析：

---

### **1. 函数原型与参数**
```c
struct device *device_create(
    struct class *class,    // 所属设备类（需先通过 class_create 创建）
    struct device *parent,  // 父设备指针（通常为 NULL）
    dev_t devt,             // 设备号（主设备号+次设备号）
    void *drvdata,         // 驱动私有数据（可传递到回调函数）
    const char *fmt, ...    // 设备名称格式（支持 printf 风格）
);
```
- **返回值**：成功返回 `struct device*` 指针，失败返回错误编码指针（需用 `IS_ERR()` 检查）。

---

### **2. 核心功能**
1. **设备对象创建**  
   - 在 `sysfs` 中（如 `/sys/class/myclass/mydevice`）创建设备对象，记录设备号、驱动数据等信息。
2. **触发 udev 规则**  
   - 通过 `sysfs` 变化通知 `udev`，自动在 `/dev` 下生成设备节点（如 `/dev/mydevice`）。
3. **动态设备号支持**  
   - 结合 `alloc_chrdev_region()` 动态分配设备号，避免硬编码。

---

### **3. 典型使用流程**
```c
// 1. 创建设备类
struct class *my_class = class_create(THIS_MODULE, "myclass");
if (IS_ERR(my_class)) {
    return PTR_ERR(my_class);
}

// 2. 创建设备节点
dev_t devno = MKDEV(major, minor);  // 或动态分配
struct device *dev = device_create(my_class, NULL, devno, NULL, "mydevice");
if (IS_ERR(dev)) {
    class_destroy(my_class);
    return PTR_ERR(dev);
}
```
- **卸载时逆序销毁**：先调用 `device_destroy()`，再 `class_destroy()`。

---

### **4. 关键注意事项**
- **错误处理**：必须检查 `IS_ERR()`，并通过 `PTR_ERR()` 获取错误码（如 `-ENOMEM`）。
- **设备号有效性**：若 `devt` 为 `0`（如 `MKDEV(0,0)`），不会生成 `/dev` 节点，仅创建 `sysfs` 对象。
- **全局存储**：返回值必须保存为全局变量，否则模块卸载时无法正确释放资源。

---

### **5. 与 `mknod` 的对比**
| 特性           | `device_create`         | `mknod`                          |
| -------------- | ----------------------- | -------------------------------- |
| **操作层级**   | 内核 API（触发 `udev`） | 用户空间工具（直接调用系统调用） |
| **设备号管理** | 动态分配（推荐）        | 需手动指定                       |
| **自动化程度** | 高（自动生成节点）      | 低（完全手动）                   |
| **适用场景**   | 现代驱动开发            | 调试或传统驱动                   |


---

### **6. 常见问题**
- **节点未生成**：检查 `udev` 服务是否运行，或 `sysfs` 权限是否正确。
- **内存泄漏**：未调用 `device_destroy()` 会导致 `sysfs` 残留条目。

通过合理使用 `device_create()`，开发者可以简化设备管理，实现动态、自动化的设备节点生成。

**tips:**

device_create 函数的返回值，推荐保存为 全局变量，但是也可以保存为局部变量。



## IS_ERR()  - linux内核API

`IS_ERR(cd)` 是 Linux 内核中的一个宏，用于判断指针 `cd` 是否是一个**错误编码的指针**。以下是详细解析：

---

### 1. **核心功能**
- **作用**：检测内核函数返回的指针是否实际表示错误（如内存分配失败、设备未找到等）。
- **原理**：内核将错误码（如 `-ENOMEM`）编码为指针值（通过 `ERR_PTR` 宏），这些指针位于内核虚拟地址空间的最后一个 page（例如 32 位系统的 `0xFFFFF000~0xFFFFFFFF`）。`IS_ERR` 通过检查指针是否落在此区间来判断是否为错误。

---

### 2. **典型使用场景**
- **设备驱动开发**：当调用内核函数（如 `ioremap`、`devm_clk_get`）返回指针时，需用 `IS_ERR` 检查是否出错：
  ```c
  struct clk *clk = devm_clk_get(dev, "uart_clk");
  if (IS_ERR(clk)) {
      int err = PTR_ERR(clk);  // 提取错误码
      printk("Failed to get clock: %d\n", err);
      return err;
  }
  ```
- **错误处理**：若 `IS_ERR(cd)` 返回 `true`，需通过 `PTR_ERR(cd)` 获取原始错误码（如 `-ENODEV`）。

---

### 3. **相关宏**
- `ERR_PTR(long error)`：将错误码转换为指针（如 `return ERR_PTR(-ENOMEM);`）。
- `PTR_ERR(const void *ptr)`：从错误指针中提取错误码。

---

### 4. **注意事项**
- **仅用于内核函数**：`IS_ERR` 仅适用于返回指针的内核函数（如 `kmalloc` 失败返回 `NULL`，不可用 `IS_ERR` 检测）。
- **调试技巧**：若误用，可通过 `printk` 打印 `PTR_ERR(cd)` 或使用 `dump_stack()` 定位问题。

---

### 示例代码
```c
void *ptr = some_kernel_function();
if (IS_ERR(ptr)) {
    int err = PTR_ERR(ptr);
    printk(KERN_ERR "Operation failed: %d\n", err);
    return err;
}
```

通过 `IS_ERR`，内核开发者可以统一处理指针和错误码，简化错误逻辑。